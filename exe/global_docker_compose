#!/usr/bin/env ruby

# TODO:
# - Publish to artifactory
# - Write example usage
# - Test how this works with multiple servicelications trying to use the same deps at the same time?
# - Test docker Kafka
# - Add lenses to docker
# - docker compose file: EXPOSE vs. PORT? Which is best here?

require 'yaml'
require 'thor'
require 'thor/base'

# @param cmd [String]
# @return [Boolean]
def run_command(cmd)
	puts "-> #{cmd}"
	system(cmd)
end

# @param cmd [String]
# @return [String]
def capture_command(cmd)
	puts "-> #{cmd}"
	`#{cmd}`
end

class CLI < Thor

	# @return [Boolean]
	def self.exit_on_failure?
		true
	end

	no_commands do

		# @return [String]
		def dc_file
			"#{__dir__}/../lib/docker-compose.yml"
		end

		# @return [Array<String>]
		def configured_services
			dc_config = YAML.load(File.read(self.dc_file))
			dc_config['services'].keys
		end

		# @param command [String]
		# @param service [String]
		def validate_service(command, service)
			service_not_found!(command, service) unless configured_services.include?(service)
		end

		# @param command [String]
		# @param service [String]
		def service_not_found!(command, service)
			say "Cannot execute command #{command} - #{service} is not a known service!", :red
			say "Known services: #{configured_services.join(' ')}"
			exit(1)
		end

		# @param command [String]
		# @return [String]
		def service_string(command)
			if options[:services].nil? || options[:services].empty?
				say "No services provided for command #{command}!", :red
				exit(1)
			end

			dc_services = configured_services
			results = []
			options[:services].each do |service|
				if dc_services.include?(service)
					results << service
					if service == 'redis'
						results << 'redisinsight'
					end
				else
					service_not_found!(command, service)
				end
			end
			results.join(' ')
		end

		# @param service [String]
		# @param command [String]
		def execute_docker_command(service, command)
			run_command("docker compose -f #{dc_file} exec #{service} #{command}")
		end

	end

	class_option(:services, type: :array)

	desc 'up', 'Creates and starts services'
	def up
		str = service_string('up')
		run_command('aws ecr get-login-password | docker login --password-stdin -u AWS 421990735784.dkr.ecr.us-east-1.amazonaws.com')
		run_command("docker compose -f #{dc_file} up -d #{str}")
	end

	desc 'down', 'Stops and removes services, leaving volumes intact'
	def down
		if options[:services] && options[:services].any?
			str = service_string('down')
			run_command("docker compose -f #{dc_file} stop #{str}")
			run_command("docker compose -f #{dc_file} rm -f #{str}")
		else
			run_command("docker compose -f #{dc_file} down")
		end
	end

	desc 'logs', 'Shows logs for your services'
	def logs
		str = service_string('logs')
		run_command("docker compose -f #{dc_file} logs -f #{str}")
	end

	desc 'exec', 'Run a command on an existing container'
	def exec(service, *command)
		validate_service('exec', service)
		execute_docker_command(service, command.join(' '))
	end

	desc 'mysql', 'Run the MySQL command line'
	def mysql
		# check which version is running
		%w(mysql56 mysql57 mysql8).each do |version|
			if options[:services].include?(version)
				execute_docker_command(version, 'mysql')
				return
			end
		end

		# not found
		say "mysql service not provided! Please use the --services option!", :red
		exit(1)
	end

end

CLI.start(ARGV)
